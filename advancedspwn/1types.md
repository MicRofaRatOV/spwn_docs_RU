# Типы данных в SPWN

Типы данных SPWN хранятся в свойстве `type`. Ты можешь проверить это, добавив свойство `type` к разным типам данных:

```spwn
extract $

print(10.type)       // @number           или число
print("hello".type)  // @string           или строка
print(10g.type)      // @group            или группа
print(10g.move.type) // @macro            или макроc
print(!{}.type)      // @trigger_function или функция триггера
```

Значение свойства `type` называется _type indicator (значение типа)_ и само является значением. Значение типа всегда начинается с `@` и продолжается именем типа.

?> _**Примечание:** Так как свойство `type` само по себе является значением, вы можете получить его тип данных, к примеру: `@number.type` вернёт `@type_indicator`_

# Нестандартные типы данных

Слова по умолчанию будет именить тип `@dictionary`. Однако вы можете самостоятельно устанавливать членов словаря, а значит вы можете установить своё свойство `type`, фактически изменив тип данных.

```spwn
my_number = {
    type: @number или число
}

// SPWN будет думать, что my_number это число, потому что my_number.type равняется @number
```

Однако не так полезно делать тип словаря, который уже существует. Это может быть полезно, если вы делаете свой собственный тип данных. Пример нового типа:

```spwn
type @person
```

Это позволит вам устанавливать новые значения с типом данных `@person`.

```spwn
person = {
    type: @person,
    age: 17,
    name: "August",
}
```

Однако писать так не совсем удобно. К счастью, есть способ писать более чисто:

```spwn
person = @person::{
    age: 17,
    name: "August",
}
```

На самом деле это одно и то же значение. Однако вторая запись получается более читабельной.

# Тип аргумента макроса

При создании макроса часто может понадобится ограничение типов аргументов, дабы избежать путаницы и ошибок. Вы можете сделать это, заранее объявив тип данных для каждого аргумента:

```spwn
add = (a: @number, b: @number) {
    return a + b
}
```

Если ваш аргумент поддерживает различные типы данных, вы можете использовать символ `|` для их объединения:

```spwn
combine = (a: @number | @string, b: @number | @string) {
    return a + b
}
```

Если вы хотите, чтобы аргумент был массивом с определённым типом данных, используйте квадратные скобки по типу:

```spwn
sum = (numbers: [@number]) {
    let out = 0
    for n in numbers {
        out += n
    }
    return out
}
```

Вы можете комбинировать эти элементы по своему желанию:

```spwn
my_crazy_macro = (arg: @number | [[@number] | @string]) {
    //...
}
```

?> _**Примечание:** Выражение после значения `argument: ` называется **pattern или шаблон**, а так же является собственным типом. Вы можете проверить, соответствует ли значение шаблону с помощью встроенного `$.matches(value, pattern)`_
